from typing import Dict, Any, List, Literal
from uuid import uuid4
from langchain_core.messages import (
    BaseMessage,
    HumanMessage,
    AIMessage,
    ToolMessage,
    ToolCall,
    ChatMessage as LangchainChatMessage,
    message_to_dict,
    messages_from_dict,
)
from langchain_core.runnables import RunnableConfig
from langchain_core.callbacks import adispatch_custom_event
from pydantic import BaseModel, Field


class UserInput(BaseModel):
    """Basic user input for the agent."""

    message: str = Field(
        description="User input to the agent.",
        examples=["What is the weather in Tokyo?"],
    )
    model: str = Field(
        description="LLM Model to use for the agent.",
        default="gpt-4o-mini",
        examples=["gpt-4o-mini", "llama-3.1-70b"],
    )
    thread_id: str | None = Field(
        description="Thread ID to persist and continue a multi-turn conversation.",
        default=None,
        examples=["847c6285-8fc9-4560-a83f-4e6285809254"],
    )


class StreamInput(UserInput):
    """User input for streaming the agent's response."""

    stream_tokens: bool = Field(
        description="Whether to stream LLM tokens to the client.",
        default=True,
    )


class AgentResponse(BaseModel):
    """Response from the agent when called via /invoke."""

    message: Dict[str, Any] = Field(
        description="Final response from the agent, as a serialized LangChain message.",
        examples=[
            {
                "message": {
                    "type": "ai",
                    "data": {"content": "The weather in Tokyo is 70 degrees.", "type": "ai"},
                }
            }
        ],
    )


class ChatMessage(BaseModel):
    """Message in a chat."""

    type: Literal["human", "ai", "tool", "task"] = Field(
        description="Role of the message.",
        examples=["human", "ai", "tool", "task"],
    )
    content: str = Field(
        description="Content of the message.",
        examples=["Hello, world!"],
    )
    tool_calls: List[ToolCall] = Field(
        description="Tool calls in the message.",
        default=[],
    )
    tool_call_id: str | None = Field(
        description="Tool call that this message is responding to.",
        default=None,
        examples=["call_Jja7J89XsjrOLA5r!MEOW!SL"],
    )
    run_id: str | None = Field(
        description="Run ID of the message.",
        default=None,
        examples=["847c6285-8fc9-4560-a83f-4e6285809254"],
    )
    original: Dict[str, Any] = Field(
        description="Original LangChain message in serialized form.",
        default={},
    )
    task_name: str | None = Field(
        description="Name of the task.", default=None, examples=["Check input safety"]
    )
    task_run_id: str = Field(
        description="ID of the task run to pair state updates to.",
        default="",
        examples=["847c6285-8fc9-4560-a83f-4e6285809254"],
    )
    task_state: Literal["new", "running", "complete"] | None = Field(
        description="Current state of given task instance.",
        default=None,
        examples=["running"],
    )
    task_result: Literal["success", "error"] | None = Field(
        description="Result of given task instance.",
        default=None,
        examples=["running"],
    )
    task_data: Dict[str, Any] = Field(description="Data generated by the task.", default={})

    @classmethod
    def from_langchain(cls, message: BaseMessage) -> "ChatMessage":
        """Create a ChatMessage from a LangChain message."""
        original = message_to_dict(message)
        match message:
            case HumanMessage():
                human_message = cls(type="human", content=message.content, original=original)
                return human_message
            case AIMessage():
                ai_message = cls(type="ai", content=message.content, original=original)
                if message.tool_calls:
                    ai_message.tool_calls = message.tool_calls
                return ai_message
            case ToolMessage():
                tool_message = cls(
                    type="tool",
                    content=message.content,
                    tool_call_id=message.tool_call_id,
                    original=original,
                )
                return tool_message
            case TaskMessage():
                task_message = cls(
                    type="task",
                    content=message.content,
                    task_name=message.name,
                    task_run_id=message.task_run_id,
                    task_state=message.state,
                    task_result=message.result,
                    task_data=message.data,
                )
                return task_message
            case _:
                raise ValueError(f"Unsupported message type: {message.__class__.__name__}")

    def to_langchain(self) -> BaseMessage:
        """Convert the ChatMessage to a LangChain message."""
        if self.original:
            return messages_from_dict([self.original])[0]
        match self.type:
            case "human":
                return HumanMessage(content=self.content)
            case _:
                raise NotImplementedError(f"Unsupported message type: {self.type}")

    def pretty_print(self) -> None:
        """Pretty print the ChatMessage."""
        lc_msg = self.to_langchain()
        lc_msg.pretty_print()


class Feedback(BaseModel):
    """Feedback for a run, to record to LangSmith."""

    run_id: str = Field(
        description="Run ID to record feedback for.",
        examples=["847c6285-8fc9-4560-a83f-4e6285809254"],
    )
    key: str = Field(
        description="Feedback key.",
        examples=["human-feedback-stars"],
    )
    score: float = Field(
        description="Feedback score.",
        examples=[0.8],
    )
    kwargs: Dict[str, Any] = Field(
        description="Additional feedback kwargs, passed to LangSmith.",
        default={},
        examples=[{"comment": "In-line human feedback"}],
    )


class TaskMessage(LangchainChatMessage):
    """Message from a background task.

    TaskMessages are returned by system to inform user about progress and results
    of background tasks.
    """

    role: str = "system_task"
    """The role of the speaker."""

    name: str
    task_run_id: str
    state: Literal["new", "running", "complete"]
    result: Literal["success", "error"] | None = None
    data: Dict = {}

    @classmethod
    def get_lc_namespace(cls) -> List[str]:
        """Get the namespace of the langchain object.
        Default is ["langchain", "schema", "messages"]."""
        return ["langchain", "schema", "messages"]

    def __init__(
        self,
        **kwargs: Any,
    ) -> None:
        super().__init__(content="", **kwargs)


class Task:
    def __init__(self, task_name: str) -> None:
        self.name = task_name
        self.id = str(uuid4())
        self.state: Literal["new", "running", "complete"] = "new"
        self.result = None

    async def start(self, config: RunnableConfig, data: Dict = {}) -> TaskMessage:
        self.state = "running"
        task_message = TaskMessage(
            name=self.name,
            task_run_id=self.id,
            state=self.state,
            data=data,
        )
        await adispatch_custom_event(
            name=self.name,
            data=task_message,
            config=config,
        )
        return task_message

    async def write_data(self, config: RunnableConfig, data: Dict) -> TaskMessage:
        if self.state != "running":
            raise ValueError("Only running tasks can output data.")
        task_message = TaskMessage(
            name=self.name,
            task_run_id=self.id,
            state=self.state,
            data=data,
        )
        await adispatch_custom_event(
            name=self.name,
            data=task_message,
            config=config,
        )
        return task_message

    async def finish(
        self, result: Literal["success", "error"], config: RunnableConfig, data: Dict = {}
    ) -> TaskMessage:
        self.state = "complete"
        self.result = result
        task_message = TaskMessage(
            name=self.name,
            task_run_id=self.id,
            state=self.state,
            result=self.result,
            data=data,
        )
        await adispatch_custom_event(
            name=self.name,
            data=task_message,
            config=config,
        )
        return task_message
